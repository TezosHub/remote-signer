"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const webcrypto = require("webcrypto-core");
const WebCryptoError = webcrypto.WebCryptoError;
const Base64Url = webcrypto.Base64Url;
const graphene_pk11_1 = require("graphene-pk11");
const graphene = require("graphene-pk11");
const base_1 = require("../base");
const key_1 = require("../key");
const utils = require("../utils");
function create_template(session, alg, extractable, keyUsages) {
    const id = utils.GUID(session);
    return {
        token: !!process.env.WEBCRYPTO_PKCS11_TOKEN,
        sensitive: !!process.env.WEBCRYPTO_PKCS11_SENSITIVE,
        class: graphene_pk11_1.ObjectClass.SECRET_KEY,
        keyType: graphene_pk11_1.KeyType.AES,
        label: `AES-${alg.length}`,
        id,
        extractable,
        derive: false,
        sign: keyUsages.indexOf("sign") !== -1,
        verify: keyUsages.indexOf("verify") !== -1,
        encrypt: keyUsages.indexOf("encrypt") !== -1,
        decrypt: keyUsages.indexOf("decrypt") !== -1,
        wrap: keyUsages.indexOf("wrapKey") !== -1,
        unwrap: keyUsages.indexOf("unwrapKey") !== -1,
    };
}
exports.create_template = create_template;
class AesCrypto extends base_1.BaseCrypto {
    static generateKey(algorithm, extractable, keyUsages, session) {
        return (super.generateKey.apply(this, arguments))
            .then(() => {
            return new Promise((resolve, reject) => {
                const template = create_template(session, algorithm, extractable, keyUsages);
                template.valueLen = algorithm.length >> 3;
                session.generateKey(graphene_pk11_1.KeyGenMechanism.AES, template, (err, aesKey) => {
                    try {
                        if (err) {
                            reject(new WebCryptoError(`Aes: Can not generate new key\n${err.message}`));
                        }
                        else {
                            const key = new key_1.CryptoKey(aesKey, algorithm);
                            resolve(key);
                        }
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            });
        });
    }
    static exportKey(format, key, session) {
        return super.exportKey.apply(this, arguments)
            .then(() => {
            return new Promise((resolve, reject) => {
                const template = key.key.getAttribute({ value: null, valueLen: null });
                switch (format.toLowerCase()) {
                    case "jwk":
                        const aes = /AES-(\w+)/.exec(key.algorithm.name)[1];
                        const jwk = {
                            kty: "oct",
                            k: Base64Url.encode(template.value),
                            alg: `A${template.valueLen * 8}${aes}`,
                            ext: true,
                        };
                        resolve(jwk);
                        break;
                    case "raw":
                        resolve(template.value.buffer);
                        break;
                    default:
                        throw new WebCryptoError(`Unknown format '${format}'`);
                }
            });
        });
    }
    static importKey(format, keyData, algorithm, extractable, keyUsages, session) {
        return super.importKey.apply(this, arguments)
            .then(() => {
            return new Promise((resolve, reject) => {
                let value;
                if (format === "jwk") {
                    value = utils.b64_decode(keyData.k);
                }
                else {
                    value = keyData;
                }
                const aesAlg = {
                    name: algorithm.name,
                    length: value.length * 8,
                };
                const template = create_template(session, aesAlg, extractable, keyUsages);
                template.value = value;
                const sessionObject = session.create(template);
                resolve(new key_1.CryptoKey(sessionObject.toType(), aesAlg));
            });
        });
    }
    static encrypt(algorithm, key, data, session) {
        return super.encrypt.apply(this, arguments)
            .then(() => {
            if (this.padding) {
                const blockLength = 16;
                const mod = blockLength - (data.length % blockLength);
                const pad = new Buffer(mod);
                pad.fill(mod);
                data = Buffer.concat([data, pad]);
            }
        })
            .then(() => {
            return new Promise((resolve, reject) => {
                session.createCipher(this.wc2pk11(algorithm), key.key).once(data, new Buffer(this.getOutputBufferSize(key.algorithm, true, data.length)), (err, data2) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(data2.buffer);
                    }
                });
            });
        });
    }
    static decrypt(algorithm, key, data, session) {
        return super.decrypt.apply(this, arguments)
            .then(() => {
            return new Promise((resolve, reject) => {
                session.createDecipher(this.wc2pk11(algorithm), key.key).once(data, new Buffer(this.getOutputBufferSize(key.algorithm, false, data.length)), (err, data2) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(data2.buffer);
                    }
                });
            });
        })
            .then((dec) => {
            if (this.padding) {
                const buf = new Buffer(dec);
                const paddingLength = buf[buf.length - 1];
                const res = new Uint8Array(buf.slice(0, buf.length - paddingLength));
                return res.buffer;
            }
            else {
                return dec;
            }
        });
    }
    static wc2pk11(alg, session) {
        throw new WebCryptoError(WebCryptoError.NOT_SUPPORTED);
    }
    static getOutputBufferSize(keyAlg, enc, dataSize) {
        const len = keyAlg.length >> 3;
        if (enc) {
            return (Math.ceil(dataSize / len) * len) + len;
        }
        else {
            return dataSize;
        }
    }
}
AesCrypto.padding = false;
exports.AesCrypto = AesCrypto;
class AesGCM extends AesCrypto {
    static wc2pk11(alg, session) {
        const aad = alg.additionalData ? utils.PrepareData(alg.additionalData) : undefined;
        let AesGcmParamsClass = graphene.AesGcmParams;
        if (session &&
            session.slot.module.cryptokiVersion.major >= 2 &&
            session.slot.module.cryptokiVersion.minor >= 40) {
            AesGcmParamsClass = graphene.AesGcm240Params;
        }
        const params = new AesGcmParamsClass(utils.PrepareData(alg.iv), aad, alg.tagLength || 128);
        return { name: "AES_GCM", params };
    }
}
exports.AesGCM = AesGCM;
class AesCBC extends AesCrypto {
    static wc2pk11(alg, session) {
        return { name: "AES_CBC_PAD", params: utils.PrepareData(alg.iv) };
    }
}
exports.AesCBC = AesCBC;
class AesECB extends AesCrypto {
    static wc2pk11(alg, session) {
        return { name: "AES_ECB", params: null };
    }
}
AesECB.padding = true;
exports.AesECB = AesECB;
