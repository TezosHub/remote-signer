"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const webcrypto = require("webcrypto-core");
const WebCryptoError = webcrypto.WebCryptoError;
const AlgorithmError = webcrypto.AlgorithmError;
const Base64Url = webcrypto.Base64Url;
const graphene_pk11_1 = require("graphene-pk11");
const graphene = require("graphene-pk11");
const base_1 = require("../base");
const key_1 = require("../key");
const utils = require("../utils");
const Asn1Js = require("asn1js");
const { PrivateKeyInfo, PublicKeyInfo } = require("pkijs");
const HASH_PREFIXES = {
    "sha-1": new Buffer([0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14]),
    "sha-256": new Buffer([0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20]),
    "sha-384": new Buffer([0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30]),
    "sha-512": new Buffer([0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40]),
};
function create_template(session, alg, extractable, keyUsages) {
    const label = `RSA-${alg.modulusLength}`;
    const idKey = utils.GUID(session);
    return {
        privateKey: {
            token: !!process.env.WEBCRYPTO_PKCS11_TOKEN,
            sensitive: !!process.env.WEBCRYPTO_PKCS11_SENSITIVE,
            class: graphene_pk11_1.ObjectClass.PRIVATE_KEY,
            keyType: graphene_pk11_1.KeyType.RSA,
            private: true,
            label,
            id: idKey,
            extractable,
            derive: false,
            sign: keyUsages.indexOf("sign") > -1,
            decrypt: keyUsages.indexOf("decrypt") > -1,
            unwrap: keyUsages.indexOf("unwrapKey") > -1,
        },
        publicKey: {
            token: !!process.env.WEBCRYPTO_PKCS11_TOKEN,
            class: graphene_pk11_1.ObjectClass.PUBLIC_KEY,
            keyType: graphene_pk11_1.KeyType.RSA,
            private: false,
            label,
            id: idKey,
            verify: keyUsages.indexOf("verify") > -1,
            encrypt: keyUsages.indexOf("encrypt") > -1,
            wrap: keyUsages.indexOf("wrapKey") > -1,
        },
    };
}
class RsaCryptoKey extends key_1.CryptoKey {
    constructor(key, algorithm) {
        super(key, algorithm);
        const alg = this.algorithm;
        alg.modulusLength = key.get("modulus").length << 3;
        alg.publicExponent = new Uint8Array(key.get("publicExponent"));
    }
}
exports.RsaCryptoKey = RsaCryptoKey;
class RsaCrypto extends base_1.BaseCrypto {
    static generateKey(algorithm, extractable, keyUsages, session) {
        return super.generateKey.apply(this, arguments)
            .then(() => {
            return new Promise((resolve, reject) => {
                const size = algorithm.modulusLength;
                const exp = new Buffer(algorithm.publicExponent);
                const template = create_template(session, algorithm, extractable, keyUsages);
                template.publicKey.publicExponent = exp;
                template.publicKey.modulusBits = size;
                session.generateKeyPair(graphene_pk11_1.KeyGenMechanism.RSA, template.publicKey, template.privateKey, (err, keys) => {
                    try {
                        if (err) {
                            reject(new WebCryptoError(`Rsa: Can not generate new key\n${err.message}`));
                        }
                        else {
                            const wcKeyPair = {
                                privateKey: new RsaCryptoKey(keys.privateKey, algorithm),
                                publicKey: new RsaCryptoKey(keys.publicKey, algorithm),
                            };
                            resolve(wcKeyPair);
                        }
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            });
        });
    }
    static async exportKey(format, key, session) {
        await super.exportKey.call(this, format, key, session);
        switch (format.toLowerCase()) {
            case "jwk":
                if (key.type === "private") {
                    return this.exportJwkPrivateKey(key);
                }
                else {
                    return this.exportJwkPublicKey(key);
                }
            case "pkcs8": {
                const jwk = await this.exportJwkPrivateKey(key);
                const privateKey = new PrivateKeyInfo();
                privateKey.fromJSON(jwk);
                return privateKey.toSchema(true).toBER(false);
            }
            case "spki": {
                const jwk = await this.exportJwkPublicKey(key);
                const publicKey = new PublicKeyInfo();
                publicKey.fromJSON(jwk);
                return publicKey.toSchema(true).toBER(false);
            }
            case "raw": {
                const jwk = await this.exportJwkPublicKey(key);
                const publicKey = new PublicKeyInfo();
                publicKey.fromJSON(jwk);
                return publicKey.toSchema(true).valueBlock.value[1].valueBlock.valueHex;
            }
            default:
                throw new Error(`Not supported format '${format}'`);
        }
    }
    static importKey(format, keyData, algorithm, extractable, keyUsages, session) {
        return super.importKey.apply(this, arguments)
            .then(() => {
            switch (format.toLowerCase()) {
                case "jwk":
                    const jwk = keyData;
                    if (jwk.d) {
                        return this.importJwkPrivateKey(session, jwk, algorithm, extractable, keyUsages);
                    }
                    else {
                        return this.importJwkPublicKey(session, jwk, algorithm, extractable, keyUsages);
                    }
                case "spki": {
                    const arBuf = new Uint8Array(keyData).buffer;
                    const asn1 = Asn1Js.fromBER(arBuf);
                    const jwk = new PublicKeyInfo({ schema: asn1.result }).toJSON();
                    return this.importJwkPublicKey(session, jwk, algorithm, extractable, keyUsages);
                }
                case "pkcs8": {
                    const arBuf = new Uint8Array(keyData).buffer;
                    const asn1 = Asn1Js.fromBER(arBuf);
                    const jwk = new PrivateKeyInfo({ schema: asn1.result }).toJSON();
                    return this.importJwkPrivateKey(session, jwk, algorithm, extractable, keyUsages);
                }
                default:
                    throw new Error(`Not supported format '${format}'`);
            }
        });
    }
    static jwkAlgName(alg) {
        throw new WebCryptoError(WebCryptoError.NOT_SUPPORTED);
    }
    static async exportJwkPublicKey(key) {
        const pkey = key.key.getAttribute({
            publicExponent: null,
            modulus: null,
        });
        const alg = this.jwkAlgName(key.algorithm);
        const jwk = {
            kty: "RSA",
            alg,
            ext: true,
            key_ops: key.usages,
            e: Base64Url.encode(pkey.publicExponent),
            n: Base64Url.encode(pkey.modulus),
        };
        return jwk;
    }
    static async exportJwkPrivateKey(key) {
        const pkey = key.key.getAttribute({
            publicExponent: null,
            modulus: null,
            privateExponent: null,
            prime1: null,
            prime2: null,
            exp1: null,
            exp2: null,
            coefficient: null,
        });
        const alg = this.jwkAlgName(key.algorithm);
        const jwk = {
            kty: "RSA",
            alg,
            ext: true,
            key_ops: key.usages,
            e: Base64Url.encode(pkey.publicExponent),
            n: Base64Url.encode(pkey.modulus),
            d: Base64Url.encode(pkey.privateExponent),
            p: Base64Url.encode(pkey.prime1),
            q: Base64Url.encode(pkey.prime2),
            dp: Base64Url.encode(pkey.exp1),
            dq: Base64Url.encode(pkey.exp2),
            qi: Base64Url.encode(pkey.coefficient),
        };
        return jwk;
    }
    static importJwkPrivateKey(session, jwk, algorithm, extractable, keyUsages) {
        return Promise.resolve()
            .then(() => {
            const template = create_template(session, algorithm, extractable, keyUsages).privateKey;
            template.publicExponent = utils.b64_decode(jwk.e);
            template.modulus = utils.b64_decode(jwk.n);
            template.privateExponent = utils.b64_decode(jwk.d);
            template.prime1 = utils.b64_decode(jwk.p);
            template.prime2 = utils.b64_decode(jwk.q);
            template.exp1 = utils.b64_decode(jwk.dp);
            template.exp2 = utils.b64_decode(jwk.dq);
            template.coefficient = utils.b64_decode(jwk.qi);
            const p11key = session.create(template).toType();
            return new RsaCryptoKey(p11key, algorithm);
        });
    }
    static importJwkPublicKey(session, jwk, algorithm, extractable, keyUsages) {
        return new Promise((resolve, reject) => {
            const template = create_template(session, algorithm, extractable, keyUsages).publicKey;
            template.publicExponent = utils.b64_decode(jwk.e);
            template.modulus = utils.b64_decode(jwk.n);
            const p11key = session.create(template).toType();
            const key = new RsaCryptoKey(p11key, algorithm);
            resolve(key);
        });
    }
}
exports.RsaCrypto = RsaCrypto;
class RsaPKCS1 extends RsaCrypto {
    static sign(algorithm, key, data, session) {
        return super.sign.apply(this, arguments)
            .then(() => {
            return new Promise((resolve, reject) => {
                const mechanism = this.wc2pk11(algorithm, key.algorithm);
                mechanism.name = this.getAlgorithm(session, mechanism.name);
                if (mechanism.name === "RSA_PKCS") {
                    data = this.prepareData(key.algorithm.hash.name, data);
                }
                session.createSign(mechanism, key.key).once(data, (err, data2) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(data2.buffer);
                    }
                });
            });
        });
    }
    static verify(algorithm, key, signature, data, session) {
        return super.verify.apply(this, arguments)
            .then(() => {
            return new Promise((resolve, reject) => {
                const mechanism = this.wc2pk11(algorithm, key.algorithm);
                mechanism.name = this.getAlgorithm(session, mechanism.name);
                if (mechanism.name === "RSA_PKCS") {
                    data = this.prepareData(key.algorithm.hash.name, data);
                }
                session.createVerify(mechanism, key.key).once(data, signature, (err, data2) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(data2);
                    }
                });
            });
        });
    }
    static prepareData(hashAlgorithm, data) {
        const hash = utils.digest(hashAlgorithm.replace("-", ""), data);
        const hashPrefix = HASH_PREFIXES[hashAlgorithm.toLowerCase()];
        if (!hashPrefix) {
            throw new Error(`Cannot get prefix for hash '${hashAlgorithm}'`);
        }
        return Buffer.concat([hashPrefix, hash]);
    }
    static getAlgorithm(session, p11AlgorithmName) {
        const mechanisms = session.slot.getMechanisms();
        const RSA = "RSA_PKCS";
        for (let i = 0; i < mechanisms.length; i++) {
            const mechanism = mechanisms.items(i);
            if (mechanism.name === RSA) {
                return RSA;
            }
        }
        return p11AlgorithmName;
    }
    static wc2pk11(alg, keyAlg) {
        let res;
        switch (keyAlg.hash.name.toUpperCase()) {
            case "SHA-1":
                res = "SHA1_RSA_PKCS";
                break;
            case "SHA-224":
                res = "SHA224_RSA_PKCS";
                break;
            case "SHA-256":
                res = "SHA256_RSA_PKCS";
                break;
            case "SHA-384":
                res = "SHA384_RSA_PKCS";
                break;
            case "SHA-512":
                res = "SHA512_RSA_PKCS";
                break;
            default:
                throw new AlgorithmError(AlgorithmError.UNSUPPORTED_ALGORITHM, keyAlg.hash.name);
        }
        return { name: res, params: null };
    }
    static jwkAlgName(alg) {
        const algName = /(\d+)$/.exec(alg.hash.name)[1];
        return `RS${algName === "1" ? "" : algName}`;
    }
}
exports.RsaPKCS1 = RsaPKCS1;
class RsaPSS extends RsaPKCS1 {
    static jwkAlgName(alg) {
        const algName = /(\d+)$/.exec(alg.hash.name)[1];
        return `RP${algName === "1" ? "" : algName}`;
    }
    static wc2pk11(alg, keyAlg) {
        let mech;
        let param;
        const saltLen = alg.saltLength;
        switch (keyAlg.hash.name.toUpperCase()) {
            case "SHA-1":
                mech = "SHA1_RSA_PKCS_PSS";
                param = new graphene.RsaPssParams(graphene_pk11_1.MechanismEnum.SHA1, graphene_pk11_1.RsaMgf.MGF1_SHA1, saltLen);
                break;
            case "SHA-224":
                mech = "SHA224_RSA_PKCS_PSS";
                param = new graphene.RsaPssParams(graphene_pk11_1.MechanismEnum.SHA224, graphene_pk11_1.RsaMgf.MGF1_SHA224, saltLen);
                break;
            case "SHA-256":
                mech = "SHA256_RSA_PKCS_PSS";
                param = new graphene.RsaPssParams(graphene_pk11_1.MechanismEnum.SHA256, graphene_pk11_1.RsaMgf.MGF1_SHA256, saltLen);
                break;
            case "SHA-384":
                mech = "SHA384_RSA_PKCS_PSS";
                param = new graphene.RsaPssParams(graphene_pk11_1.MechanismEnum.SHA384, graphene_pk11_1.RsaMgf.MGF1_SHA384, saltLen);
                break;
            case "SHA-512":
                mech = "SHA512_RSA_PKCS_PSS";
                param = new graphene.RsaPssParams(graphene_pk11_1.MechanismEnum.SHA512, graphene_pk11_1.RsaMgf.MGF1_SHA512, saltLen);
                break;
            default:
                throw new AlgorithmError(AlgorithmError.UNSUPPORTED_ALGORITHM, keyAlg.hash.name);
        }
        return { name: mech, params: param };
    }
}
exports.RsaPSS = RsaPSS;
class RsaOAEP extends RsaCrypto {
    static encrypt(algorithm, key, data, session) {
        return super.encrypt.apply(this, arguments)
            .then(() => {
            return new Promise((resolve, reject) => {
                session.createCipher(this.wc2pk11(algorithm, key.algorithm), key.key).once(data, new Buffer(key.algorithm.modulusLength >> 3), (err, data2) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(data2.buffer);
                    }
                });
            });
        });
    }
    static decrypt(algorithm, key, data, session) {
        return super.decrypt.apply(this, arguments)
            .then(() => {
            return new Promise((resolve, reject) => {
                session.createDecipher(this.wc2pk11(algorithm, key.algorithm), key.key).once(data, new Buffer(key.algorithm.modulusLength >> 3), (err, data2) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(data2.buffer);
                    }
                });
            });
        });
    }
    static jwkAlgName(alg) {
        const algName = /(\d+)$/.exec(alg.hash.name)[1];
        return `RSA-OAEP${algName === "1" ? "" : ("-" + algName)}`;
    }
    static wc2pk11(alg, keyAlg) {
        let params;
        const sourceData = alg.label ? new Buffer(alg.label) : undefined;
        switch (keyAlg.hash.name.toUpperCase()) {
            case "SHA-1":
                params = new graphene.RsaOaepParams(graphene_pk11_1.MechanismEnum.SHA1, graphene_pk11_1.RsaMgf.MGF1_SHA1, sourceData);
                break;
            case "SHA-224":
                params = new graphene.RsaOaepParams(graphene_pk11_1.MechanismEnum.SHA224, graphene_pk11_1.RsaMgf.MGF1_SHA224, sourceData);
                break;
            case "SHA-256":
                params = new graphene.RsaOaepParams(graphene_pk11_1.MechanismEnum.SHA256, graphene_pk11_1.RsaMgf.MGF1_SHA256, sourceData);
                break;
            case "SHA-384":
                params = new graphene.RsaOaepParams(graphene_pk11_1.MechanismEnum.SHA384, graphene_pk11_1.RsaMgf.MGF1_SHA384, sourceData);
                break;
            case "SHA-512":
                params = new graphene.RsaOaepParams(graphene_pk11_1.MechanismEnum.SHA512, graphene_pk11_1.RsaMgf.MGF1_SHA512, sourceData);
                break;
            default:
                throw new AlgorithmError(AlgorithmError.UNSUPPORTED_ALGORITHM, keyAlg.hash.name);
        }
        const res = { name: "RSA_PKCS_OAEP", params };
        return res;
    }
}
exports.RsaOAEP = RsaOAEP;
