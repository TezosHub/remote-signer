"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const webcrypto = require("webcrypto-core");
const AlgorithmError = webcrypto.AlgorithmError;
const PrepareAlgorithm = webcrypto.PrepareAlgorithm;
const AlgorithmNames = webcrypto.AlgorithmNames;
const const_1 = require("./const");
const key_1 = require("./key");
const aes = require("./crypto/aes");
const ec = require("./crypto/ec");
const rsa = require("./crypto/rsa");
const sha = require("./crypto/sha");
const utils = require("./utils");
class SubtleCrypto extends webcrypto.SubtleCrypto {
    constructor(crypto) {
        super();
        this.crypto = crypto;
    }
    digest(algorithm, data) {
        return super.digest.apply(this, arguments)
            .then(() => {
            const alg = PrepareAlgorithm(algorithm);
            const data2 = utils.PrepareData(data);
            const algName = alg.name.toLowerCase();
            let AlgClass;
            switch (algName) {
                case "sha-1":
                case "sha-224":
                case "sha-256":
                case "sha-384":
                case "sha-512":
                    AlgClass = sha.ShaCrypto;
                    break;
                default:
                    throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, algName);
            }
            return AlgClass.digest(alg, data2, this.crypto.session);
        });
    }
    generateKey(algorithm, extractable, keyUsages) {
        return super.generateKey.apply(this, arguments)
            .then(() => {
            const alg = PrepareAlgorithm(algorithm);
            let AlgClass;
            switch (alg.name.toLowerCase()) {
                case AlgorithmNames.RsaSSA.toLowerCase():
                    AlgClass = rsa.RsaPKCS1;
                    break;
                case AlgorithmNames.RsaPSS.toLowerCase():
                    AlgClass = rsa.RsaPSS;
                    break;
                case AlgorithmNames.RsaOAEP.toLowerCase():
                    AlgClass = rsa.RsaOAEP;
                    break;
                case AlgorithmNames.AesECB.toLowerCase():
                    AlgClass = aes.AesECB;
                    break;
                case AlgorithmNames.AesCBC.toLowerCase():
                    AlgClass = aes.AesCBC;
                    break;
                case AlgorithmNames.AesGCM.toLowerCase():
                    AlgClass = aes.AesGCM;
                    break;
                case AlgorithmNames.EcDSA.toLowerCase():
                case AlgorithmNames.EcDH.toLowerCase():
                    AlgClass = ec.EcCrypto;
                    break;
                default:
                    throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, alg.name);
            }
            return AlgClass.generateKey(alg, extractable, keyUsages, this.crypto.session)
                .then((keys) => {
                const publicKey = keys.publicKey;
                const privateKey = keys.privateKey;
                if (publicKey) {
                    return this.exportKey("raw", publicKey)
                        .then((spki) => {
                        const digest = utils.digest(const_1.ID_DIGEST, spki);
                        publicKey.key.id = digest;
                        publicKey.id = key_1.CryptoKey.getID(publicKey.key);
                        privateKey.key.id = digest;
                        privateKey.id = key_1.CryptoKey.getID(privateKey.key);
                        return keys;
                    });
                }
                else {
                    return keys;
                }
            });
        });
    }
    wrapKey(format, key, wrappingKey, wrapAlgorithm) {
        return super.wrapKey.apply(this, arguments)
            .then(() => {
            return this.exportKey(format, key)
                .then((exportedKey) => {
                let data;
                if (!(exportedKey instanceof ArrayBuffer)) {
                    data = new Buffer(JSON.stringify(exportedKey));
                }
                else {
                    data = new Buffer(exportedKey);
                }
                return this.encrypt(wrapAlgorithm, wrappingKey, data);
            });
        });
    }
    unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {
        return super.unwrapKey.apply(this, arguments)
            .then(() => {
            return Promise.resolve()
                .then(() => {
                return this.decrypt(unwrapAlgorithm, unwrappingKey, wrappedKey);
            })
                .then((decryptedKey) => {
                let keyData;
                if (format === "jwk") {
                    keyData = JSON.parse(new Buffer(decryptedKey).toString());
                }
                else {
                    keyData = new Buffer(decryptedKey);
                }
                return this.importKey(format, keyData, unwrappedKeyAlgorithm, extractable, keyUsages);
            });
        });
    }
    encrypt(algorithm, key, data) {
        return super.encrypt.apply(this, arguments)
            .then(() => {
            const alg = PrepareAlgorithm(algorithm);
            const data2 = utils.PrepareData(data);
            let AlgClass;
            switch (alg.name.toLowerCase()) {
                case AlgorithmNames.RsaOAEP.toLowerCase():
                    AlgClass = rsa.RsaOAEP;
                    break;
                case AlgorithmNames.AesECB.toLowerCase():
                    AlgClass = aes.AesECB;
                    break;
                case AlgorithmNames.AesCBC.toLowerCase():
                    AlgClass = aes.AesCBC;
                    break;
                case AlgorithmNames.AesGCM.toLowerCase():
                    AlgClass = aes.AesGCM;
                    break;
                default:
                    throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, alg.name);
            }
            return AlgClass.encrypt(alg, key, data2, this.crypto.session);
        });
    }
    decrypt(algorithm, key, data) {
        return super.decrypt.apply(this, arguments)
            .then(() => {
            const alg = PrepareAlgorithm(algorithm);
            const data2 = utils.PrepareData(data);
            let AlgClass;
            switch (alg.name.toLowerCase()) {
                case AlgorithmNames.RsaOAEP.toLowerCase():
                    AlgClass = rsa.RsaOAEP;
                    break;
                case AlgorithmNames.AesECB.toLowerCase():
                    AlgClass = aes.AesECB;
                    break;
                case AlgorithmNames.AesCBC.toLowerCase():
                    AlgClass = aes.AesCBC;
                    break;
                case AlgorithmNames.AesGCM.toLowerCase():
                    AlgClass = aes.AesGCM;
                    break;
                default:
                    throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, alg.name);
            }
            return AlgClass.decrypt(alg, key, data2, this.crypto.session);
        });
    }
    exportKey(format, key) {
        return super.exportKey.apply(this, arguments)
            .then(() => {
            let AlgClass;
            switch (key.algorithm.name.toLowerCase()) {
                case AlgorithmNames.RsaSSA.toLowerCase():
                    AlgClass = rsa.RsaPKCS1;
                    break;
                case AlgorithmNames.RsaPSS.toLowerCase():
                    AlgClass = rsa.RsaPSS;
                    break;
                case AlgorithmNames.RsaOAEP.toLowerCase():
                    AlgClass = rsa.RsaOAEP;
                    break;
                case AlgorithmNames.AesECB.toLowerCase():
                    AlgClass = aes.AesECB;
                    break;
                case AlgorithmNames.AesCBC.toLowerCase():
                    AlgClass = aes.AesCBC;
                    break;
                case AlgorithmNames.AesGCM.toLowerCase():
                    AlgClass = aes.AesGCM;
                    break;
                case AlgorithmNames.EcDSA.toLowerCase():
                case AlgorithmNames.EcDH.toLowerCase():
                    AlgClass = ec.EcCrypto;
                    break;
                default:
                    throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, key.algorithm.name);
            }
            return AlgClass.exportKey(format, key, this.crypto.session);
        });
    }
    importKey(format, keyData, algorithm, extractable, keyUsages) {
        return super.importKey.apply(this, arguments)
            .then(() => {
            const alg = PrepareAlgorithm(algorithm);
            let data = keyData;
            if (format !== "jwk") {
                data = utils.PrepareData(data);
            }
            let AlgClass;
            switch (alg.name.toLowerCase()) {
                case AlgorithmNames.RsaSSA.toLowerCase():
                    AlgClass = rsa.RsaPKCS1;
                    break;
                case AlgorithmNames.RsaPSS.toLowerCase():
                    AlgClass = rsa.RsaPSS;
                    break;
                case AlgorithmNames.RsaOAEP.toLowerCase():
                    AlgClass = rsa.RsaOAEP;
                    break;
                case AlgorithmNames.AesECB.toLowerCase():
                    AlgClass = aes.AesECB;
                    break;
                case AlgorithmNames.AesCBC.toLowerCase():
                    AlgClass = aes.AesCBC;
                    break;
                case AlgorithmNames.AesGCM.toLowerCase():
                    AlgClass = aes.AesGCM;
                    break;
                case AlgorithmNames.EcDSA.toLowerCase():
                case AlgorithmNames.EcDH.toLowerCase():
                    AlgClass = ec.EcCrypto;
                    break;
                default:
                    throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, alg.name);
            }
            return AlgClass.importKey(format, data, alg, extractable, keyUsages, this.crypto.session)
                .then((key) => {
                if (key.type === "public") {
                    return this.exportKey("raw", key)
                        .then((spki) => {
                        const digest = utils.digest(const_1.ID_DIGEST, spki);
                        key.key.id = digest;
                        key.id = key_1.CryptoKey.getID(key.key);
                        return key;
                    });
                }
                else {
                    return key;
                }
            });
        });
    }
    sign(algorithm, key, data) {
        return super.sign.apply(this, arguments)
            .then(() => {
            const alg = PrepareAlgorithm(algorithm);
            const data2 = utils.PrepareData(data);
            let AlgClass;
            switch (alg.name.toLowerCase()) {
                case AlgorithmNames.RsaSSA.toLowerCase():
                    AlgClass = rsa.RsaPKCS1;
                    break;
                case AlgorithmNames.RsaPSS.toLowerCase():
                    AlgClass = rsa.RsaPSS;
                    break;
                case AlgorithmNames.EcDSA.toLowerCase():
                    AlgClass = ec.Ecdsa;
                    break;
                default:
                    throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, alg.name);
            }
            return AlgClass.sign(alg, key, data2, this.crypto.session);
        });
    }
    verify(algorithm, key, signature, data) {
        return super.verify.apply(this, arguments)
            .then(() => {
            const alg = PrepareAlgorithm(algorithm);
            const signature2 = utils.PrepareData(signature);
            const data2 = utils.PrepareData(data);
            let AlgClass;
            switch (alg.name.toLowerCase()) {
                case AlgorithmNames.RsaSSA.toLowerCase():
                    AlgClass = rsa.RsaPKCS1;
                    break;
                case AlgorithmNames.RsaPSS.toLowerCase():
                    AlgClass = rsa.RsaPSS;
                    break;
                case AlgorithmNames.EcDSA.toLowerCase():
                    AlgClass = ec.Ecdsa;
                    break;
                default:
                    throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, alg.name);
            }
            return AlgClass.verify(alg, key, signature2, data2, this.crypto.session);
        });
    }
    deriveKey(algorithm, baseKey, derivedKeyType, extractable, keyUsages) {
        return super.deriveKey.apply(this, arguments)
            .then(() => {
            const alg = PrepareAlgorithm(algorithm);
            const derivedKeyType2 = PrepareAlgorithm(derivedKeyType);
            let AlgClass;
            switch (alg.name.toLowerCase()) {
                case AlgorithmNames.EcDH.toLowerCase():
                    AlgClass = ec.Ecdh;
                    break;
                default:
                    throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, alg.name);
            }
            return AlgClass.deriveKey(alg, baseKey, derivedKeyType2, extractable, keyUsages, this.crypto.session);
        });
    }
    deriveBits(algorithm, baseKey, length) {
        return super.deriveBits.apply(this, arguments)
            .then(() => {
            const alg = PrepareAlgorithm(algorithm);
            let AlgClass;
            switch (alg.name.toLowerCase()) {
                case AlgorithmNames.EcDH.toLowerCase():
                    AlgClass = ec.Ecdh;
                    break;
                default:
                    throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, alg.name);
            }
            return AlgClass.deriveBits(alg, baseKey, length, this.crypto.session);
        });
    }
}
exports.SubtleCrypto = SubtleCrypto;
