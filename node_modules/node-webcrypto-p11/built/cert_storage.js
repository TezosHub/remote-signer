"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphene_pk11_1 = require("graphene-pk11");
const cert_1 = require("./cert");
const utils = require("./utils");
const TEMPLATES = [
    { class: graphene_pk11_1.ObjectClass.CERTIFICATE, certType: graphene_pk11_1.CertificateType.X_509, token: true },
    { class: graphene_pk11_1.ObjectClass.DATA, token: true, label: "X509 Request" },
];
class CertificateStorage {
    constructor(crypto) {
        this.crypto = crypto;
    }
    async indexOf(item) {
        if (item instanceof cert_1.CryptoCertificate && item.p11Object.token) {
            return cert_1.CryptoCertificate.getID(item.p11Object);
        }
        return null;
    }
    async keys() {
        const keys = [];
        TEMPLATES.forEach((template) => {
            this.crypto.session.find(template, (obj) => {
                const item = obj.toType();
                const id = cert_1.CryptoCertificate.getID(item);
                keys.push(id);
            });
        });
        return keys;
    }
    async clear() {
        const objects = [];
        TEMPLATES.forEach((template) => {
            this.crypto.session.find(template, (obj) => {
                objects.push(obj);
            });
        });
        objects.forEach((obj) => {
            obj.destroy();
        });
    }
    async getItem(key, algorithm, usages) {
        const storageObject = this.getItemById(key);
        if (storageObject instanceof graphene_pk11_1.X509Certificate) {
            const x509Object = storageObject.toType();
            const x509 = new cert_1.X509Certificate(this.crypto);
            x509.p11Object = x509Object;
            await x509.exportKey(algorithm, usages);
            return x509;
        }
        else if (storageObject instanceof graphene_pk11_1.Data) {
            const x509Object = storageObject.toType();
            const x509request = new cert_1.X509CertificateRequest(this.crypto);
            x509request.p11Object = x509Object;
            await x509request.exportKey(algorithm, usages);
            return x509request;
        }
        else {
            return null;
        }
    }
    async removeItem(key) {
        const sessionObject = this.getItemById(key);
        if (sessionObject) {
            sessionObject.destroy();
        }
    }
    async setItem(data) {
        if (!(data instanceof cert_1.CryptoCertificate)) {
            throw new Error("Incoming data is not PKCS#11 CryptoCertificate");
        }
        if (!data.p11Object.token) {
            const obj = this.crypto.session.copy(data.p11Object, {
                token: true,
            });
            return cert_1.CryptoCertificate.getID(obj.toType());
        }
        else {
            return data.id;
        }
    }
    async exportCert(format, cert) {
        switch (format) {
            case "pem": {
                throw Error("PEM format is not implemented");
            }
            case "raw": {
                return cert.exportCert();
            }
            default:
                throw new Error(`Unsupported format in use ${format}`);
        }
    }
    async importCert(type, data, algorithm, usages) {
        const preparedData = utils.PrepareData(data);
        switch (type.toLowerCase()) {
            case "x509": {
                const x509 = new cert_1.X509Certificate(this.crypto);
                await x509.importCert(preparedData, algorithm, usages);
                return x509;
            }
            case "request": {
                const request = new cert_1.X509CertificateRequest(this.crypto);
                await request.importCert(preparedData, algorithm, usages);
                return request;
            }
            default:
                throw new Error(`Wrong value for parameter type. Must be x509 or request`);
        }
    }
    getItemById(id) {
        let object = null;
        TEMPLATES.forEach((template) => {
            this.crypto.session.find(template, (obj) => {
                const item = obj.toType();
                if (id === cert_1.CryptoCertificate.getID(item)) {
                    object = item;
                    return false;
                }
            });
        });
        return object;
    }
}
exports.CertificateStorage = CertificateStorage;
