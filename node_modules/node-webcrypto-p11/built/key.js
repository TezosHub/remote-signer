"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const webcrypto_core_1 = require("webcrypto-core");
const graphene_pk11_1 = require("graphene-pk11");
const p11_object_1 = require("./p11_object");
class CryptoKey extends p11_object_1.Pkcs11Object {
    constructor(key, alg) {
        super(key);
        this.usages = [];
        switch (key.class) {
            case graphene_pk11_1.ObjectClass.PUBLIC_KEY:
                this.initPublicKey(key.toType());
                break;
            case graphene_pk11_1.ObjectClass.PRIVATE_KEY:
                this.initPrivateKey(key.toType());
                break;
            case graphene_pk11_1.ObjectClass.SECRET_KEY:
                this.initSecretKey(key.toType());
                break;
            default:
                throw new webcrypto_core_1.WebCryptoError(`Wrong incoming session object '${graphene_pk11_1.ObjectClass[key.class]}'`);
        }
        this.algorithm = alg;
        this.id = CryptoKey.getID(key);
    }
    static getID(p11Key) {
        let name;
        switch (p11Key.class) {
            case graphene_pk11_1.ObjectClass.PRIVATE_KEY:
                name = "private";
                break;
            case graphene_pk11_1.ObjectClass.PUBLIC_KEY:
                name = "public";
                break;
            case graphene_pk11_1.ObjectClass.SECRET_KEY:
                name = "secret";
                break;
            default:
                throw new Error(`Unsupported Object type '${graphene_pk11_1.ObjectClass[p11Key.class]}'`);
        }
        return `${name}-${p11Key.handle.toString("hex")}-${p11Key.id.toString("hex")}`;
    }
    get key() {
        return this.p11Object.toType();
    }
    toJSON() {
        return {
            algorithm: this.algorithm,
            type: this.type,
            usages: this.usages,
            extractable: this.extractable,
        };
    }
    initPrivateKey(key) {
        this.p11Object = key;
        this.type = "private";
        try {
            this.extractable = key.extractable;
        }
        catch (e) {
            this.extractable = false;
        }
        this.usages = [];
        if (key.decrypt) {
            this.usages.push("decrypt");
        }
        if (key.derive) {
            this.usages.push("deriveKey");
            this.usages.push("deriveBits");
        }
        if (key.sign) {
            this.usages.push("sign");
        }
        if (key.unwrap) {
            this.usages.push("unwrapKey");
        }
    }
    initPublicKey(key) {
        this.p11Object = key;
        this.type = "public";
        this.extractable = true;
        if (key.encrypt) {
            this.usages.push("encrypt");
        }
        if (key.verify) {
            this.usages.push("verify");
        }
        if (key.wrap) {
            this.usages.push("wrapKey");
        }
    }
    initSecretKey(key) {
        this.p11Object = key;
        this.type = "secret";
        try {
            this.extractable = key.extractable;
        }
        catch (e) {
            this.extractable = false;
        }
        if (key.encrypt) {
            this.usages.push("encrypt");
        }
        if (key.verify) {
            this.usages.push("verify");
        }
        if (key.wrap) {
            this.usages.push("wrapKey");
        }
        if (key.decrypt) {
            this.usages.push("decrypt");
        }
        if (key.derive) {
            this.usages.push("deriveKey");
            this.usages.push("deriveBits");
        }
        if (key.sign) {
            this.usages.push("sign");
        }
        if (key.unwrap) {
            this.usages.push("unwrapKey");
        }
    }
}
exports.CryptoKey = CryptoKey;
